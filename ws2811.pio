; https://datasheets.raspberrypi.org/rp2040/rp2040-datasheet.pdf
; 3.5.6.3 Input Synchronisers
; To protect PIO from metastabilities, each GPIO input is equipped with a standard
; 2-flipflop synchroniser. This adds two cycles of latency to input sampling [...]

.program ws2811
.side_set 1 opt

.define PUBLIC NUM_LEDS_TO_EMULATE 2 ; number of WS2811 chips to emulate


; if y != 0, then pass through all bits until we get a reset pulse
; if y == 0, then just wait for a reset pulse
.wrap_target
pass_through_wait_for_next_bit:
    set x 20
    mov osr x
    out null, 5 ; shift left 5 times
    mov x, osr  ; x = 20 * 2^5 640 -> 640*2*8ns = 10240ns
pass_through_wait_for_next_bit_loop:
    jmp pin pass_through                              ; start of next bit detected -> pass through
    jmp x-- pass_through_wait_for_next_bit_loop       ; loop until a reset pulse is detected

; reset pulse detected -> start reading bits

read_bits:
    mov isr !null ; signal start of leds

    ;;;;;;;;;;;;;;;
    ; set y to 47 ;
    ;;;;;;;;;;;;;;;
    set y 24
    mov osr y
    out null, 1 ; shift left 1 times
    mov y, osr  ; y = 24 * 2^1 = 48
    jmp y-- read_bits_rearm_reset_counter ; y = 47 (always jumps to read_bits_rearm_reset_counter)

read_bits_rearm_reset_counter:
    set x 20
    mov osr x
    out null, 5 ; shift left 5 times
    mov x, osr  ; x = 20 * 2^5 640 -> 640*2*8ns = 10240ns

wait_bit:             ; wait for bit to arrive
    jmp pin bit_start ; bit pulse started!
    jmp x-- wait_bit  ; if x > 0, continue waiting for next bit, otherwise fall through
    ; reset pulse detected while we expected further bits
    jmp read_bits     ; -> read bits again

bit_start:
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; delay for approximately 492ns ;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    set x 5            [1]  ; 2 cycles
delay_loop:                 ; + 6*(
    nop                [4]  ;     5 cycles
    jmp x-- delay_loop [4]  ;   + 5 cycles) = 62 cycles -> 62*8ns = 496ns

    ; alternative implementation (1 instruction less, but does not allow side stepping for debugging)

;    nop                 [30] ; 31 cycles
;    nop                 [30] ; + 31 cycles = 62 cycles -> 62*8ns = 496ns

    ; now check if this is a 1 or 0 bit

    in pins, 1                                   ; shift 1 or 0 into result
    wait 0 pin 0                                 ; wait for pulse end
    jmp y-- read_bits_rearm_reset_counter        ; wait for next bit
    ; bits are all read now
    set y 1 ; set y flag to pass through all remaining bits
    .wrap



pass_through:
    jmp !y skip_pass_through           ; if y == 0, do not pass through
    set pins 1                         ;
skip_pass_through:
    wait 0 pin 0                       ; wait for low
    set pins 0                         ;
    jmp pass_through_wait_for_next_bit ; wait for next pass through bit, reset reset pulse counter
